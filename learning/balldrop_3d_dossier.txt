Header files

#include <core/ApiVersion.h>
This is not native to C++ but is a part of the Chrono::DEME platform. It is related to the concept of Semantic Versioning (SemVers) where softwware versions are numbered so we can understand what changes are included.
SemVers basic concept:
The changes to programs follow the following format:
1. Major: Big changes that could break things (could mess with the dependencies).
2. Minor: New features that generally do not break dependencies.  
3. Patch: Small/minor fixes like bug fixes
Where does the ApiVersion.h header file come in?
It defines the versioning information of DEME before initialization of the code. It is not necessary to go deeper than this for this header file. It's basically a bridge between the build configuration and the source code. 

#include <core/utils/ThreadManager.h>
This is also a DEME header file. It does the behind the scenes scheduling of tasks and allocation of threads for each time step. This ensures that the kinematic (contact detection) thread and the dynamic (force calculation or time integration) thread work in tandem.
It is also not necessary to go deeper than this because it has little relevance in terms of application of the software.

#include <DEM/API.h>
Analogous to importing a library in Python. By "including" this file, I am essentially copying and pasting the contents of this file to my source code before compilation. This differs from Python, where a module or library is compiled separately and imported as an object. My goal here is to not become a software engineer so the analogy, while imperfect, will do for me. 

#include <DEM/HostSideHelpers.hpp>
This header file, in the crudest understanding possible, helps to facilitate smooth interaction between the source code and the host environment. Host environment here is defined as the compute node where I use cmake to build the code, and also the node(s) that I use to run the code. 

#include <DEM/utils/Samplers.hpp>
This is very important to understand. It includes the sampling algorithms used to generate particle positions before the "kinematic" thread detects contact. You can write your own algorithms, but the disadvantage is that you would have to think of all the edge cases and potential issues with premature contact detection. Will go into much more details. 

The list of samplers used in DEME are:
1. Poisson's Disk (PD) sampler.
2. Hexagonally Closed Packed (HCP) sampler.
3. Grid Sampler

In addition to these, there are specialized wrappers which are essentially the modifications of the aforementioned samplers. They are:
1. Box Grid Sampler: Grid sampler but for a defined box domain.
2. Box HCP Sampler: Generates an HCP arrangement within a box volume
3. CylSurf Sampler: Generates points that form a cylindrical surface shell. Specialized to create a layer of points around the surface of a cylinder. 

Now we go to the header files that are native to C++. You need to understand at the most basic level at least what they do and why are they required before going into the main function. They are:
#include <cstdio>
The purpose of this header file is to provide C-style input and output facilities. It is the part of the C standard library support in C++, and includes functions such as 'printf', 'scanf', 'fopen', 'fclose' etc. It is "language agnostic" as it is compatible with both C and C++.
An alternative to this is the iostream library. cstdio is likely used here to ensure legacy code compatibility.

#include <chrono>
This header defines time utilities in the C++ standard library. It provides a set of time duration, clock, and time point types for expressing system and steady clock times, performing time arithmetic, and converting between time units. Very important because we use "clock time" and "real world time" in DEM simulations (will get into it later).

#include <filesystem>
This name is very self explanatory. It is responsible for file and directory handling (creating, copying, moving, deleting, modifying, etc).

The three headers that I touched upon before are crucial to build and run the source code. Apart from them, we can import (or "include", to be more true to the language), project-specific header files. 

#include <random>
This is included in this code to generate random numbers. I could go deeper into this header but it is not worth it.  

The concept of namespace in C++
Namespace is a way to encapsulate a set of names (like variables, functions, and classes) so that they can be distinguished from similar names in other namespaces. It's a method to organize the sourcecode into logical groups. 
It is essentially a group of names that is analogous to a python module. It can be defined inside a header file and that allows us to use the namespace name directly without defining the underlying functions or variables over and over again. 
For instance, if there is a namespace x which has a function y defined inside a header file namez.h, you can include that header file in your code and call y without defining it. 

back to the code,
using namespace deme;
-this namespace is defined in the DEM/API.h header file and allows you to call DEME specific functions without explicitly defining them over and over again)

using namespace std::filesystem;
-this namespace is defined within the filesystem header file. This namespace is called into action further below where a directory is created to store the output files. 

Random number generation logic (not absolutely essential for my work but worth examining to understand function definition syntax)
double randomBetween0and1() {
    static std::mt19937 gen(std::random_device{}());                       // Random number generator
    static std::uniform_real_distribution<double> distribution(0.0, 1.0);  // Uniform distribution between 0 and 1

    return distribution(gen);
}

the simple definition format here is: 
return_type function name(constituent variables){
		body.....
		return xyz;
	}

Here is the logic behind the random number generation:

static std::mt19937 gen(std::random_device{}());


Here, static is a storage class specifier for the variable 'gen'. It ensures that the variable is initialized only once and lasts for the lifetime of the program. In essence, the lifetime of the variable is global but it is local to the function. 
std:mt19937 is one of the pseudorandom number generator class defined in the '<random>' header of the C++ standard library. 
std::random{}() device is a random number generator that generates "true random" numbers leveraging any hardware source of randomness. In this instance, it is used to generate the seed for the pseudorandom number generator. This ensures unpredictability in generating the random number even by a determinisitic way.
Not very relevant but still interesting.

MAIN FUNCTION
float ball_densities[] = {2.2e3, 3.8e3, 7.8e3, 15e3};
a list of values that are the densities of the dropping ball are initialized. A list in C++ is initialized as:
variable_type name[] = {list content};

float Hs[] = {0.05, 0.1, 0.2};
a list of heights from which the ball would be dropped is initialized

double R = 0.0254 / 2.;
Maybe particle diameter??

int run_num = 0;
integer variable that stores the number of unique runs (unique combinations of drop heights and densities)

for (float ball_density : ball_densities) {
        for (float H : Hs) {
            double terrain_rad = 0.0025 / 2.;
a nested for loop is initialized where the float variable ball_density is iterated through the list of densities in the parent loop and the float variable H is iterated through the list of drop heights in the child loop.

			DEMSolver DEMSim;
            // Output less info at initialization
            DEMSim.SetVerbosity("ERROR");
            DEMSim.SetOutputFormat("CSV");
            DEMSim.SetOutputContent({"ABSV"});
            DEMSim.SetMeshOutputFormat("VTK");

Step by step explanation of the above snippet:
1. Declare and initialize the object 'DEMSim' of the 'DEMSolver' class, allocating it on the stack and setting it up with its default constructor for use in the simulation.
2. Set the verbosity level of the output to "ERROR". It can alternate between "ERROR" or "INFO" amongst other options that I have to look into. 
3. Set the output format of the particle positions, relative velocities, and sizes as a csv file.
4. Set the absolute velocity (absv) of the particles as one of the contents in the aforementioned csv file.
5. Set the output format of the mesh (the ball or balls in this case) into a vtk file. 

	path out_dir = current_path();
	out_dir += "/DemoOutput_BallDrop";
	create_directory(out_dir);

Here the namespace std::filesystem is in action. If that namespace were not invoked in the beginning, this block would look like:
std::filesystem::path out_dir = std::filesystem::current_path();
out_dir += "/DemoOutput_BallDrop";
std::filesystem::create_directory(out_dir);
We are just creating a folder called "DemoOutput_BallDrop" in the build directory (which is also the current path) to store the output.


  
